# shell编程

计算机执行需要机器语言，人和计算机之间的翻译官叫做编译器或者叫做解释器，这取决于你使用的语言类型。计算机语言分为**机器语言**、**汇编语言**，**高级语言**（接近于人类的自然语言）。在高级语言中又分为静态语言（编译型语言）和动态语言（解释型语言）。通常情况下，编译型语言通常是强类型（变量），解释型通常是弱类型（变量）。静态语言需要事先转换为可执行格式，动态语言边解释边执行。常见的静态语言有C，C++,Java，C#;动态语言有php，shell，python，perl。

编程模型分为**面向过程**和**面向对象**

## 变量和变量类型

变量是**内存空间**，内存空间是由名称的，内存是编址的存储单元，每一个内存单元都有全局唯一的编址

变量名称只能包含数字、字母和下划线，并且不能以数字开头；不应该和系统中已有的环境变量重名；做好做到见名知意

先看一个例子，你要在内存中存储一个字符串10和一个数字10，它们需要的内存空间大小会一样么？如果是字符串那在计算机中要使用ASCII码来表示，那么字符串10需要占用内存16位2字节的空间，而数字10转换为二进制位1010，但是计算机最小内存单元是字节，所以数字10占用8位1字节的内存空间。

从上面的例子不难看出，需要指定变量类型，变量类型直接决定的了变量的存储的格式和长度

常见的变量类型有

- 字符


- 数值：整型和浮点型
- 真、假


对于强类型的语言在变量使用前，必须事先声明，甚至还需要初始化

对于弱类型语言，直接使用，甚至不区分变量类型

**变量赋值**

变量名=值

## bash的变量类型

- 环境变量：作用域为当前shell进程及其子进程
- 本地变量（局部变量）：是进程的变量，进程结束后，变量存储的值也会消失。
- 位置变量 ：\$1,\$2 引用参数
- 特殊变量：保存特殊变量。**$?**表示上一个命令执行状态返回值 **$#**表示参数的个数**\$\***表示**\$@**表示 **shift** 运行一次shift就把一个参数剔除，使第二个参数轮替成为第一个参数

引用变量\${VARNAME},括号可以省略，但如果涉及到改变变量内容的时候括号不可以省略，如a=pig ${a}s变量为pigs，此时括号不可省略

定义局部变量**local** VARNAME=VALUE,作用域为当前代码段

本地变量的作用域为bash进程

定义环境变量使用**export** VARNAME=VALUE

脚本在执行时会启动一个子shell进程。命令行中启动的脚本会继承当前shell的环境变量，系统自动执行的脚本（非命令行启动）就需要自我定义需要的各种环境变量。

程序执行可能会有两种返回值，**执行结果**和**程序状态返回代码**（0-255）。0表示正确执行，1-255是错误执行，其中1，2，127是系统系统预留，其他用户可自定义

有时只需要命令的程序状态返回码，并不需要程序的执行结果，可以使用重定向到/dev/null目录下，这个目录是软件设备目录页称为数据黑洞

**撤销变量**

unset 变量名称

查看当前shell的所有变量`set`

查看当前shell的环境变量`printenv` `env` `export`

增加变量的内容a=1，a=$a:1 

## 脚本

一般来说是命令的堆砌，按实际需要，结合命令流程控制机制的源程序

脚本的第一行\#!/bin/bash

以#开头是注释行，不执行

加执行权限后，指定路径执行，也可以不加执行权限，使用指定解释器，bash ./test.sh

## 条件判断

### 方法一

**条件测试类型有三种：**

1. 整数测试


1. 字符测试
2. 文件测试

**条件测试的表达式：**

1. [ Expression ]
2. [ [ Expression ] ]
3. test expression

**整数比较**

-eq：测试两个整数是否相等。相等为真，不等为假。比如\$a -eq \$ b

-ne：测试两个整数是否不等，不等为真，相等为假

-gt：测试一个数是否大于另一个数，大于为真，否则为假

-lt：测试一个数是否小于另一个数，小于为真，否则为假

-ge：大于或等于

-le：小于或等于

只有使用这6个测试的关键字才需要加中括号

**命令间的逻辑关系**

逻辑与：&&    如果用户user6不存在就添加用户user6` ! id user6 && useradd user6`

​	第一个条件为假时，第二个条件不再判断，最终结果已经有了；

​	第一个条件为真时，第二个条件必须判断

​	**有假则假**

逻辑或：||      如果用户user6不存在就添加用户user6`id user6 || useradd user6`

​	第一个条件为真时，第二个条件不再判断

​	第一个条件为假时，第二个条件必须判断

​	**有真则真**

如果用户存在，就显示用户已存在，否则就添加该用户

id user1 && echo 'user1 exist' || useradd user1

如果用户不存在，就添加，否则显示其已存在

! id user1 && useradd user1 || echo 'user1 exist'

如果用户不存在，添加并设置密码，否则显示其已经存在

! id user1 && useradd user1 && echo 'user1 | passwd --stdin user1' || echo 'user1 exists'

**添加三个用户u1，u2，u3，但要先判断用户是否存在，不存在的添加，并显示当前系统共有多少个用户**

\#! /bin/bash

! id u1 &> /dev/null && useradd u1  && echo "u1"  | passwd stdin u1 &> /dev/null || echo 'user exists'

! id u2 &> /dev/null && useradd u2  && echo "u2"  | passwd stdin u2 &> /dev/null || echo 'user exists'

! id u3 &> /dev/null && useradd u3  && echo "u3"  | passwd stdin u3 &> /dev/null || echo 'user exists'

USERS=\`wc -l /etc/passswd | cut -d: -f1`

echo "$USERS users"

给定一个用户，判断用户uid，如果为0显示为管理员

\#! /bin/bash

NAME=user1

USERID='id -u $NAME'

[ $USERID -eq 0]  && echo "Admin" || echo " common user"

### 方法二

使用if 判断条件，满足条件时then执行命令

**单分支的if语句**

```shell
if 判断条件;then
    statement1
    statement2
    ......
fi
```

**双分支的if语句**

```shell
if 判断条件;then
    statement1
    statement2
    ......
else
    statement1
    statement2
    ......
fi
```

**多分支if语句**

```shell
if 判断条件1;then
    statement1
    ......
elif  判断条件2;then
    statement2
    ......   
elif  判断条件2;then
    statement3
    ...... 
elif  判断条件3;then
    statement4
    ...... 
else
    statement5
    ......
fi
```

判断用户名是否存在

```shell
NAME=user1
if id $NAME &> /dev/null;then
    echo "$NAME exists!"
else
    useradd $NAME
    echo $NAME | passwd --stdin $NAME &>/dev/null
    echo "Add $NAME finished!"
fi
```

判断UID号码是否为0

```SHELL
NAME=user16
USERID=`id -u $NAME` #反引号表示引用的命令执行结果
if [ $USERID -eq 0 ];then
    echo 'Admin'
else
    echo 'Common user'
fi
```

上面一个例子中USERID=\`id -u $NAME\` ,反引号表示引用的命令执行结果，而如果是if id \$NAME;then 此时引用的是命令的执行状态返回值，表示的是判断用户是否存在

**练习**

- 写一个脚本，判断当前系统山是否有用户默认shell是bash；如果有，就显示当前有多少个这类用户；否则就显示没有此类用户

```shell
#! /bin/bash
grep "\<bash$" /etc/passwd &>/dev/null
RETVAL=$?
if [ $RETVAL -eq 0 ];then
    users=`grep "\<bash$" /etc/passwd | wc -l`
    echo "$users uses bash"
else
    echo "no such users"
fi
```

- 判断当前系统上是否有用户的默认shell是bash；如果有，就显示其中一个用户名；否则就显示没有这类用户

```shell
  #! /bin/bash
  grep "\<bash$" /etc/passwd &>/dev/null
  RETVAL=$?
  if [ $RETVAL -eq 0 ];then    
      AUSER=`grep "\>bash$" /etc/passwd | head -1 | cut -d: -f1`  
      echo "$AUSER is one of such users use bash"
  else
      echo "no such users"
  fi
```

- 给定一个文件/etc/inittab,判断这个文件是否有空白行，如果有就显示其空白行数；否则显示没有空白行

```shell
#! /bin/bash
FILE=/etc/inittab
if grep "^$" $FILE &> /dev/null;then
    echo "Total blank lines: `grep "^$" $FILE | wc -l`."
else
    echo "No blank line"
fi
```

- 给定一个用户，判断其UID和GID是否一样，如果一样，就显示此用户为good guy，否则就显示“bad guy”

```shell
#! /bin/bash
USERNAME=user1
USERID=`id -u $USERNAME`
GROUPID=`id -g $GROUPID`
if [ $USERID -eq $GROUPID];then
    echo "Good guy"
else
    echo "Bad guy"
fi
不使用id命令获得其id号，如何完成该脚本？
#! /bin/bash
USERNAME=user1
USERID=`grep "^$USERNAME\>" /etc/passwd | cut -d: -f3`
GROUPID=`grep "^$USERNAME\>" /etc/passwd | cut -d: -f4`
if [ $USERID -eq $GROUPID ];then
    echo "Good Guy"
else
    echo "Bad Guy"
fi
```

- 给定一个用户，获得其密码警告期限，而后判断用户密码使用期限是否已经小于警告期限，如果小于则显示“Warning”；否则就显示OK

```shell
#! /bin/bash
```

- 判定命令历史中历史命令的总条目是否大于1000，如果大于则显示“Some commands will gone”;否则显示“OK”

```shell
#! /bin/bash
HIST=history | tail -1 | cut -d'' -f2
if [ $HIST gt 1000];then
    echo "Some commands will gone"
else
    echo "OK"
fi
```

## 算数运算

- 使用**let**, `let 算数运算表达式` let C=\$A+\$B
- \$[算数运算表达式] C=\$[\$A+\$B]
- \$((算数运算表达式)) \$((\$A+\$B))
- expr 算数运算符（表达式中各操作数及运算符之间要有空格，而且要是有命令引用）\`expr \$A + \$B\`


## 退出脚本

使用**exit**命令提前退出脚本，可以自定义执行状态结果 使用`exit 定义的数值`

```shell
#! /bin/bash
USERNAME=user1

if ! grep "^$USERNAME\>" /etc/passwd &> /dev/null;then
    echo "No such user:$USERNAME"
    exit 1
fi

USERID=`grep "^$USERNAME\>" /etc/passwd | cut -d: -f3`
GROUPID=`grep "^$USERNAME\>" /etc/passwd | cut -d: -f4`
if [ $USERID -eq $GROUPID ];then
    echo "Good Guy"
else
    echo "Bad Guy"
fi
```

如果脚本没有明确定义退出状态码，那么最后执行的一条命令的状态码就是脚本退出的状态码

## 文件测试

- -e 文件名或者文件路径：测试文件是否存在
- -f FILE：测试文件是否为普通文件
- -d FILE：测试指定路径是否为目录
- -r，-w,-x FILE:测试当前用户对指定文件是否有读、写、执行权限

[ -e /etc/inittab ]中括号前后需要有空格

```shell
#! /bin/bash
FILE=/etc/inittab
if [ ! -e $FILE ];then
    echo "No $FILE"
    exit 8
fi

if grep "^$" $FILE &> /dev/null;then
    echo "Total blank lines: `grep "^$" $FILE | wc -l`."
else
    echo "No blank line"
fi
```
- 给定一个文件判断是否存在，存在就显示存在，没有就显示不存在


```shell
#！ /bin/bash
FILE=/etc/inittab
if [ -e $FILE ];then
    echo "OK"
else
    echo "No"
fi
```

- 给定一个文件判断是否存在，存在就显示文件的类型，没有就显示不存在


```shell
#! /bin/bash
FILE=/etc/rc.d/rc.sysinit
if [ ! -e $FILE ];then
    echo "No such file"
    exit 6
fi
if [-f $FILE ];then
    echo "Commin file"
elif [ -d $FILE];then
    echo "Directiry"
else
    echo "Unknown"
fi 
```

- 写一个脚本，能接受一个参数（文件路径），判断此参数如果是一个存在的文件，就显示OK；否则就显示“No such file”

```shell
#! /bin/bash
if [ $# -lt 1 ];then
    echo "Usage ./file3.sh ARG1 [AGR2 ......]"
    exit 7
if [ -e $1 ];then
    echo "OK"
else 
    echo "No such file"
fi
```

- 写一个脚本，给脚本传递两个参数(整数)；显示两者之和、之积

```shell
#! \bin/bash
if [ $# -lt 2 ];then
    echo "Usage:file.sh ARG1 ARG2"
    exit 8
fi
echo "The sum is \$[$1+$2]."
echo "The prod is \$[$1\*$2]."
fi
```

## 字符串测试

- 等值比较：比较字符串是否一致：==或者=，注意等号两端要有空格
- 不等值比较：使用!=，不等为真，相等为假
- 测试指定字符串是否为空：-n string 空为真，不空为假
- 测试指定字符串是否不空：-s string 不空为真，空则为假

```shell
#！bin/bash
if ! id $1 &>/dev/null;then
    echo "No such user"
    exit 10
fi
if [  $1 == `id -n -g $1` ];then
   echo "yiyang"
else
    echo "buyiyang"
```

传递一个参数给脚本，如果是q或者quit（Quit）就退出脚本，否则就显示用户的参数

```shell
#！bin/bash

if [ $1 = "q" ];then
    echo "Quiting......"
    exit 1
elif [ $1 = "Q" ];then
    echo "Quiting......"
    exit 2
elif [  $1 = "Quit" ];then
    echo "Quiting......"
    exit 3
elif [ $1 = "quit" ];then
    echo "Quiting......"
     exit 4
else
    echo $1
fi
也可以使用正则表达式
```

## 测试脚本是否有语法错误

bash -n 脚本名称或者脚本路径

bash -x 脚本名称 单步执行

