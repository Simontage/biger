# linux系统启动流程

## 一个简单的操作系统的组成

一个操作系统（linux）主要由内核（kernel）和根文件系统（rootfs）组成，系统运行后的某一时刻，不是在执行内核代码就是在rootfs上某个路径的某个应用程序的用户代码。系统输出的调用叫做系统调用，库所输出的调用叫做库调用，当把程序源代码编译成二进制文件后，调用的是二进制格式的库文件，所以开发环境的接口和运行环境的接口不完全相同。程序员写程序时虽然要发起系统调用，但通常不是直接调用系统调用，而是调用把系统调用再次封装后的，离用户更近的库调用（glibc）。

glibc是一个标准库，是开发接口，头文件说明了glibc中有哪些库，每一个库的内部有多少可调用函数，每一个函数的名字和接受的参数等。所以开发过程中应该有库文件、头文件，然后才可以编译，编译完成后，当需要依赖于某一库时，就直接调用二进制格式的库，将其装载到共享内存中，程序就可以运行了。实际上glibc已经是属于用户空间中的内容了。glibc在/{lib|lib64}、/usr/{lib|lib64}、/usr/local/{lib|lib64}目录中。

库是函数的集合，函数的英文是function，实际上一个函数就是一个功能，函数有调用接口，还可以接受参数。库也是二进制程序，没有执行入口，所以不能直接运行，只能被调用后运行。库被调用后可以产生返回值也可以不产生返回值，一般来说函数调用（function）有返回值，过程调用（procedure）没有返回值。

内核的主要功能有进程管理、内存管理、网络管理、驱动程序、文件系统、安全功能。

根文件系统中最重要的就是二进制文件，其他的类似帮助文件统统没有也可以正常运行，所以操作系统最核心的就是内核和用户空间的二进制程序。

## linux内核

在内核设计中有两种流派，一种是微内核，一种是单内核。单内核是指把所有功能做成一个程序，各功能以线程来协同工作。而微内核是将每一个功能都是用一个独立的子系统来实现，子系统在一个框架下统一调配。Linux是单内核设计，Windows和Solaris是微内核设计的。

linux虽然是单内核设计，但却借鉴了微内核的思想，linux将内核的不同功能做成了功能模块，内核的模块也可以被调用，和库被用户程序调用一样，内核模块可以被内核调用，内核模块也被称为内核对象（kernel object），是以.ko结尾的文件。linux的内核还支持模块的动态装载和卸载，这样只保留内核的核心功能，其他的功能模块需要时加载，内核的核心模块的大小就小的很多了，模块化的另外一个好处就是将硬件驱动程序作为一个内核模块不会影响整个内核的稳定和安全。所以linux的内核就由核心文件和模块文件组成，还有一个非必要的模块叫做rmdisk。

内核的核心文件在/boot目录下vmlinuz-VERSION-release，模块文件在/lib/modules/VERSION-release，内核模块的目录名必须和内核核心文件的版本号发行号完全匹配。模块间也会存在依赖关系，所以在模块文件目录中也会有文件存储依赖关系。

rmdisk是为了解决在系统启动时，需要读取硬盘但又无法驱动硬盘的问题，rmdisk是一个虚拟的根文件系统，存放了驱动硬盘必要的文件。rmdisk和内核在同一个位置上，当内核被装载进内存时，rmdisk也被装载到内存。rmdisk是用户安装操作系统最后一步生成的，在centos5是使用mkintrd工具生成的，rmdisk在centos5中模拟的是硬盘（/boot/initrd-VERSION-release.img），在centos6之后使用的是dracut工具生成的，模拟的是文件系统(/boot/initramfs-VERSION-release.img)。内核的特性之一就是使用缓冲和缓存来加速系统运行，当使用在内存中的虚拟硬盘，内核仍然认为硬盘慢，会将文件再一次放到内存中，所以在centos6之后，改为了文件系统。

## CentOS系统启动流程

**1.加电自检（POST）**：加电自检用来检查各硬件是否正常。加电自检的过程是通过主板上ROM芯片（CMOS）所定义的一些程序来实现的，CMOS可以做一些设定，是在通过基本输入输出系统（BIOS）实现的。

**2.引导加载次序（BOOT Sequence）**：按BIOS设定的引导次序依次加载设备，第一个有引导程序的设备即为本次启动的设备，没有boot loader无法引导，会跳过此设备 。

对linux而言有两种引导加载器，早些时候使用的是LILO(Linux Loader)，现在在安卓上又有了用武之处，现在在桌面系统和服务器上使用的是GRUB（Grand Unified Boot Loader），它支持启动Windows、linux，Unix。GRUB有两个版本，分为Grub Legacy和grub2，二代是完全重写的，在centos5和6中使用的一代grub；centos7中使用的是二代grub。

Boot Loader就是用来找到操作系统所在的磁盘分区，并把内核解压并加载到内存的指定空间中，最后将控制权转交给内核。对于硬盘来说，Boot Loader就在硬盘的MBR中，MBR中前446字节存放bootloader，64字节是磁盘分区表（fat）和两字节标记符。

GRUB运行有两个阶段，第一个阶段是运行MBR中的Boot Loader，目的是为了找到硬盘中的第二阶段，第二阶段运行存放在硬盘上的某个分区上的程序。如果第二块硬盘有分区，那么grub就必须能要能识别文件系统才能继续运行，那么在第一阶段和第二阶段之间就要运行1.5阶段。在硬盘上/boot/grub中有各种文件可以用来grub驱动文件系统，但1.5阶段需要的文件也在硬盘上，实际上在系统安装时，分区的文件系统就已经确定了，所以需要的/boot/grub的某个文件就在第一阶段的mbr中的某一段位置上了。

**3.内核初始化**：内核探测各种可识别到的硬件并加载（可能借助于rmdisk）硬件驱动程序、以只读方式挂载根文件系统。以只读的方式的方式挂载根文件系统是因为fsck可以安全地对根文件系统做检查。

**4.init初始化**：内核初始化后，就该进行用户空间的初始化，如何初始化就由init的配置文件决定了。在centos5中，init使用的是Sys V，init的配置文件在/etc/inittab中；在centos6中，使用的是upstart，init的配置文件在/etc/inittab/和/etc/init/*.conf；在centos7中，init的"配置文件"在/usr/lib/systemd/system和/etc/systemd/system中。

以centos5为例：

系统运行级别是为了系统的运行或维护等应用目的而设定的，一般分为0-6七个级别，默认级别为3或5，运行级别的改变都是通过init应用程序进行的，切换级别使用init 级别数字，查看级别使用runlevel（centos7不支持），也可以使用who -r。

这七个级别分别是：

0：关机	

1：单用户模式single，维护模式，以root用户登录，无需密码

2：多用户模式，维护模式，会启动网络功能，不启动网络文件系统（NFS）

3：多用户模式，正常模式，默认为文本界面

4：预留级别，同3级别

5：多用户模式，图形界面

6：重启

init的配置文件

/etc/inittab每一行定义一种action以及与之对应的process。格式为id：runlevel：action：process

inittab的部分内容：

![](http://om8bgr2y6.bkt.clouddn.com/initdefault.png)

![](http://om8bgr2y6.bkt.clouddn.com/inittab-getttys.png)

id是一行的标识，runlevel表示对应的process会在那个级别上启动，action指明process运行的模式，process是执行的操作。

常用的action

- wait：切换至此级别运行一次；
- respawn：此process终止就重新启动；
- initdefault：设定默认级别，process省略；
- sysinit：设定系统初始化方式，一般指定为/etc/rc.d/rc.sysinit

当init开始启动，读取配置文件/etc/inittab，第一行`id:5:initdefault:`，说明了系统的默认运行级别，随后`si::sysinit:/etc/rc.d/rc.sysinit`,运行级别为空代表所有级别，设定了运行级别后，就会运行rc.sysinit的所有脚本，这个process基本运行许多的系统初始化任务。接下来就是运行指定级别下的脚本如`l3:3:wait:/etc/rc.d/rc 3`。

实际上rc是脚本，后面的数字是传递给脚本的参数，rc 3就意味着要读取/etc/rc.d/rc3.d/的所有文件。这里面的文件是以K和S开头，中间有两位数字，后有服务名的文件，先按顺序读取K开头的文件，并且传递stop参数，数字越小越优先执行，因此被依赖的应该后执行，所以数字就大一些。然后以S开头的文件按顺序读取，并传递start参数。

![](http://om8bgr2y6.bkt.clouddn.com/rc.d.png)

![](http://om8bgr2y6.bkt.clouddn.com/rc0.d.png)

如果想要把一个服务开机自启动就可以在正常级别（默认级别）的目录下创建一个s开头的链接文件。每一个脚本在每一个级别下都有一个链接文件，可以是s开头也可能成k开头，这取决于系统的运行级别。

chkconfig可以管理链接文件，也可以查看指定的服务在某个级别是否运行，chkconfig --list可以列出所有的服务在所有级别的设定;

这些服务脚本在开头有一行是chkconfig: - 23 84，第一段表示使用chkconfig时，在哪些级别设置为s，-表示在所有级别都不设置为s，如果手动修改了，第二个是s开头的数字，第三个字段是以k开头脚本的字段。另外upstart格式会更详细，两种格式都可以被chkconfig使用。

SysV的服务脚本放置于/etc/rc.d/init.d(/etc/init.d)，要想设置脚本在各级别的开启和关闭要使用chkconfig --add name，表示在7个级别的目录中分别创建链接文件，是s还是k文件有脚本内的设置有关。

使用chkconfig [--level levels] name \<on|off|reset>修改指定的链接类型。省略level时表示2345。

