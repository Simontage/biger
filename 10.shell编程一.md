# shell编程

计算机执行需要机器语言，人和计算机之间的翻译官叫做编译器或者叫做解释器，这取决于你使用的语言类型。计算机语言分为**机器语言**、**汇编语言**，**高级语言**（接近于人类的自然语言）。在高级语言中又分为静态语言（编译型语言）和动态语言（解释型语言）。通常情况下，编译型语言通常是强类型（变量），解释型通常是弱类型（变量）。静态语言需要事先转换为可执行格式，动态语言边解释边执行。常见的静态语言有C，C++,Java，C#;动态语言有php，shell，python，perl。

编程模型分为**面向过程**和**面向对象**

## 变量和变量类型

变量是**内存空间**，内存空间是由名称的，内存是编址的存储单元，每一个内存单元都有全局唯一的编址

变量名称只能包含数字、字母和下划线，并且不能以数字开头；不应该和系统中已有的环境变量重名；做好做到见名知意

先看一个例子，你要在内存中存储一个字符串10和一个数字10，它们需要的内存空间大小会一样么？如果是字符串那在计算机中要使用ASCII码来表示，那么字符串10需要占用内存16位2字节的空间，而数字10转换为二进制位1010，但是计算机最小内存单元是字节，所以数字10占用8位1字节的内存空间。

从上面的例子不难看出，需要指定变量类型，变量类型直接决定的了变量的存储的格式和长度

常见的变量类型有

- 字符


- 数值：整型和浮点型
- 真、假


对于强类型的语言在变量使用前，必须事先声明，甚至还需要初始化

对于弱类型语言，直接使用，甚至不区分变量类型

**变量赋值**

变量名=值

## bash的变量类型

- 环境变量：作用域为当前shell进程及其子进程
- 本地变量（局部变量）：是进程的变量，进程结束后，变量存储的值也会消失。
- 位置变量 
- 特殊变量：保存特殊变量。**$?**表示上一个命令执行状态返回值

引用变量\${VARNAME},括号可以省略，但如果涉及到改变变量内容的时候括号不可以省略，如a=pig ${a}s变量为pigs，此时括号不可省略

定义局部变量**local** VARNAME=VALUE,作用域为当前代码段

本地变量的作用域为bash进程

定义环境变量使用**export** VARNAME=VALUE

脚本在执行时会启动一个子shell进程。命令行中启动的脚本会继承当前shell的环境变量，系统自动执行的脚本（非命令行启动）就需要自我定义需要的各种环境变量。

程序执行可能会有两种返回值，**执行结果**和**程序状态返回代码**（0-255）。0表示正确执行，1-255是错误执行，其中1，2，127是系统系统预留，其他用户可自定义

有时只需要命令的程序状态返回码，并不需要程序的执行结果，可以使用重定向到/dev/null目录下，这个目录是软件设备目录页称为数据黑洞

**撤销变量**

unset 变量名称

查看当前shell的所有变量`set`

查看当前shell的环境变量`printenv` `env` `export`

增加变量的内容a=1，a=$a:1 

## 脚本

一般来说是命令的堆砌，按实际需要，结合命令流程控制机制的源程序

脚本的第一行\#!/bin/bash

以#开头是注释行，不执行

加执行权限后，指定路径执行，也可以不加执行权限，使用指定解释器，bash ./test.sh

## 条件判断

### 方法一

**条件测试类型有三种：**

1. 整数测试


1. 字符测试
2. 文件测试

**条件测试的表达式：**

1. [ Expression ]
2. [ [ Expression ] ]
3. test expression

**整数比较**

-eq：测试两个整数是否相等。相等为真，不等为假。比如\$a -eq \$ b

-ne：测试两个整数是否不等，不等为真，相等为假

-gt：测试一个数是否大于另一个数，大于为真，否则为假

-lt：测试一个数是否小于另一个数，小于为真，否则为假

-ge：大于或等于

-le：小于或等于

**命令间的逻辑关系**

逻辑与：&&    如果用户user6不存在就添加用户user6` ! id user6 && useradd user6`

​	第一个条件为假时，第二个条件不再判断，最终结果已经有了；

​	第一个条件为真时，第二个条件必须判断

​	**有假则假**

逻辑或：||      如果用户user6不存在就添加用户user6`id user6 || useradd user6`

​	第一个条件为真时，第二个条件不再判断

​	第一个条件为假时，第二个条件必须判断

​	**有真则真**

如果用户存在，就显示用户已存在，否则就添加该用户

id user1 && echo 'user1 exist' || useradd user1

如果用户不存在，就添加，否则显示其已存在

! id user1 && useradd user1 || echo 'user1 exist'

如果用户不存在，添加并设置密码，否则显示其已经存在

! id user1 && useradd user1 && echo 'user1 | passwd --stdin user1' || echo 'user1 exists'

**添加三个用户u1，u2，u3，但要先判断用户是否存在，不存在的添加，并显示当前系统共有多少个用户**

\#! /bin/bash

! id u1 &> /dev/null && useradd u1  && echo "u1"  | passwd stdin u1 &> /dev/null || echo 'user exists'

! id u2 &> /dev/null && useradd u2  && echo "u2"  | passwd stdin u2 &> /dev/null || echo 'user exists'

! id u3 &> /dev/null && useradd u3  && echo "u3"  | passwd stdin u3 &> /dev/null || echo 'user exists'

USERS=\`wc -l /etc/passswd | cut -d: -f1`

echo "$USERS users"

给定一个用户，判断用户uid，如果为0显示为管理员

\#! /bin/bash

NAME=user1

USERID='id -u $NAME'

[ $USERID -eq 0]  && echo "Admin" || echo " common user"

### 方法二

使用if 判断条件，满足条件时then执行命令

单分支的if语句

if 判断条件;then

​    statement1

​    statement2

​    statement3 

​    ......

fi

双分支的if语句

if 判断条件;then

​    statement1

​    statement2

​    statement3 

​    ......

else

​    statement1

​    statement2

​    statement3

​    ......

fi

```shell
NAME=user1
if id $NAME &> /dev/null;then
    echo "$NAME exists!"
else
    useradd $NAME
    echo $NAME | passwd --stdin $NAME &>/dev/null
    echo "Add $NAME finished!"
fi
```

```SHELL
NAME=user16
USERID=`id -u $NAME` #反引号表示引用的命令执行结果
if [ $USERID -eq 0 ];then
    echo 'Admin'
else
    echo 'Common user'
fi
```

上面一个例子中USERID=\`id -u $NAME\` ,反引号表示引用的命令执行结果，而如果是if id \$NAME;then 此时引用的是命令的执行状态返回值，表示的是判断用户是否存在

**练习**

- 写一个脚本，判断当前系统山是否有用户默认shell是bash；如果有，就显示当前有多少个这类用户；否则就显示没有此类用户

```shell
#! /bin/bash
grep "\<bash$" /etc/passwd &>/dev/null
RETVAL=$?
if [ $RETVAL -eq 0 ];then
    users=`grep "\<bash$" /etc/passwd | wc -l`
    echo "$users uses bash"
else
    echo "no such users"
fi
```

- 判断当前系统上是否有用户的默认shell是bash；如果有，就显示其中一个用户名；否则就显示没有这类用户

```shell
  #! /bin/bash
  grep "\<bash$" /etc/passwd &>/dev/null
  RETVAL=$?
  if [ $RETVAL -eq 0 ];then    
      AUSER=`grep "\>bash$" /etc/passwd | head -1 | cut -d: -f1`  
      echo "$AUSER is one of such users use bash"
  else
      echo "no such users"
  fi
```

- 给定一个文件/etc/inittab,判断这个文件是否有空白行，如果有就显示其空白行数；否则显示没有空白行

```shell
#! /bin/bash

```

- 给定一个用户，判断其UID和GID是否一样，如果一样，就显示此用户为good guy，否则就显示“bad guy”

```shell
#! /bin/bash
USERNAME=user1
USERID=`id -u $USERNAME`
GROUPID=`id -g $GROUPID`
if [ $USERID -eq $GROUPID];then
    echo "Good guy"
else
    echo "Bad guy"
fi
不使用id命令获得其id号，如何完成该脚本？
```

- 给定一个用户，获得其密码警告期限，而后判断用户密码使用期限是否已经小于警告期限，如果小于则显示“Warning”；否则就显示OK

```shell
#! /bin/bash
```

- 判定命令历史中历史命令的总条目是否大于1000，如果大于则显示“Some commands will gone”;否则显示“OK”

```shell
#! /bin/bash

```

## 算数运算

- 使用**let**, `let 算数运算表达式` let C=\$A+\$B
- \$[算数运算表达式] C=\$[\$A+\$B]
- \$((算数运算表达式)) \$((\$A+\$B))
- expr 算数运算符（表达式中各操作数及运算符之间要有空格，而且要是有命令引用）\`expr \$A + \$B\`

