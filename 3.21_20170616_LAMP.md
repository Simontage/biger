# LAMP

LAMP是一套应用组合，L是linux，A是apache，M是mariadb或mysql等，P是php、perl或python。也还有LAMMP，另外一个M是memcached。

HTTP协议可以传输超文本和多媒体资源，这类资源叫做静态资源，这些内容从服务端到客户端都没有改变。而动态资源一般在服务端是一个程序，而传输到客户端的是程序的执行结果。

当客户端请求一个动态资源时，web服务端会将客户端的请求发送给相关的程序解释器，程序解释器运行后将结果返回给web服务端，然后web服务端将数据封装成响应报文发送。在web服务端和后台的相关程序之间，使用CGI来进行交互。httpd有一个模块cgi_module就是实现CGI协议的模块，httpd就是CGI的客户端。如果相关的程序解释器作为一个服务通过套接字与web服务端通信，这种CGI叫做fastCGI。

一个程序是有指令和数据组成，读取文本文件中的数据进行查找，效率低下，因此为了更高效快速的完成对数据的处理查找，所以使用了专门的数据管理系统，比如数据库。程序和数据管理系统之间通过数据库的应用层协议进行沟通，程序可以调用库，库可以将程序的请求封装称为数据库可以理解的报文还可以接收并还原数据库发送的协议报文。

安装这些程序包使用yum -y install httpd php php-mysql mariadb-server（CentOS 7）

yum -y install httpd php php-mysql mysql-server(CentOS 6)

启动mariadb后使用`ss -tnl`检查3306端口是否监听用以确定是否服务是否启动

**httpd和php的结合方式有三种：**

- php作为httpd的模块

  ![rpm -ql php](http://om8bgr2y6.bkt.clouddn.com/php.png)

- fastcgi(fpm)

- cgi


**简单验证组合是否可用**

1. 安装完成php后，将php模块载入到httpd，重启httpd，启动mariadb。需要注意的是当前安装php是针对于httpd的prefork机制工作的，如果httpd使用其他MPM，需要使用其他的php rpm包

   ```
   CentOS 7
   systemctl start httpd
   systemctl start mariadb
   CentOS 6
   service httpd start
   service mysqld start
   ```

2. 在/var/www/html下建立test_php.php用来测试php是否可以工作。使用浏览器访问该页面

   ```php+HTML
   <?php
      phpinfo(); #php内置信息页，显示运行环境
   ?>
   ```

3. 在/var/www/html下建立test_db.php用来测试php是否可以连接到mariadb。如果网页无法访问数据库，需要确认selinux是否是关闭状态。

   ```php
   <?php
       $conn=mysql_connect('127.0.0.1','mysql','');
       if ($conn)
           echo "Success";
       else
           echo "Failure";
       mysql_close();

   ?>
   ```

动手：wordpress和phpMyAdmin

**php解释器如何与Mariadb交互**：php解释器是php程序运行环境，不需要与数据库通信，用到数据存储系统的程序才需要与数据存储交互。

存储系统有文件系统、SQL、NoSQL、...

- 文件系统：文件
- SQL：Mariadb、Oracle、MSSQL、...
- NoSQL：redis、mongodb、hbase、...
- NewSQL

## php

PHP是通用服务器端脚本编程语言，其主要用于web开发以实现动态web页面，它也是最早实现将脚本嵌入HTML源码文档中的服务器端脚本语言之一。同时，php还提供了一个命令行接口，因此，其也可以在大多数系统上作为一个独立的shell来使用。

Rasmus Lerdorf于1994年开始开发PHP，它是初是一组被Rasmus Lerdorf称作“Personal Home Page Tool” 的Perl脚本， 这些脚本可以用于显示作者的简历并记录用户对其网站的访问。后来，Rasmus Lerdorf使用C语言将这些Perl脚本重写为CGI程序，还为其增加了运行Web forms的能力以及与数据库交互的特性，并将其重命名为“Personal Home Page/Forms Interpreter”或“PHP/FI”。此时，PHP/FI已经可以用于开发简单的动态web程序了，这即是PHP 1.0。1995年6月，Rasmus Lerdorf把它的PHP发布于comp.infosystems.www.authoring.cgi Usenet讨论组，从此PHP开始走进人们的视野。1997年，其2.0版本发布。

1997年，两名以色列程序员Zeev Suraski和Andi Gutmans重写的PHP的分析器(parser)成为PHP发展到3.0的基础，而且从此将PHP重命名为PHP: Hypertext Preprocessor。此后，这两名程序员开始重写整个PHP核心，并于1999年发布了Zend Engine 1.0，这也意味着PHP 4.0的诞生。2004年7月，Zend Engine 2.0发布，由此也将PHP带入了PHP 5时代。PHP5包含了许多重要的新特性，如增强的面向对象编程的支持、支持PDO(PHP Data Objects)扩展机制以及一系列对PHP性能的改进。

Zend Engine是开源的、PHP脚本语言的解释器，它最早是由以色列理工学院(Technion)的学生Andi Gutmans和Zeev Suraski所开发，Zend也正是此二人名字的合称。后来两人联合创立了Zend Technologies公司。

Zend Engine 1.0于1999年随PHP 4发布，由C语言开发且经过高度优化，并能够做为PHP的后端模块使用。Zend Engine为PHP提供了内存和资源管理的功能以及其它的一些标准服务，其高性能、可靠性和可扩展性在促进PHP成为一种流行的语言方面发挥了重要作用。

Zend Engine的出现将PHP代码的处理过程分成了两个阶段：首先是分析PHP代码并将其转换为称作Zend opcode的二进制格式(类似Java的字节码)，并将其存储于内存中；第二阶段是使用Zend Engine去执行这些转换后的Opcode。

Opcode是一种PHP脚本编译后的中间语言，就像Java的ByteCode,或者.NET的MSL。PHP执行PHP脚本代码一般会经过如下4个步骤(确切的来说，应该是PHP的语言引擎Zend)：

1. Scanning(Lexing) —— 将PHP代码转换为语言片段(Tokens)
2. Parsing —— 将Tokens转换成简单而有意义的表达式
3. Compilation —— 将表达式编译成Opocdes
4. Execution —— 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能

扫描-->分析-->编译-->执行

基于PHP的特殊扩展机制如opcode缓存扩展也可以将opcode缓存于php的共享内存中，从而可以让同一段代码的后续重复执行时跳过编译阶段以提高性能。由此也可以看出，这些加速器并非真正提高了opcode的运行速度，而仅是通过分析opcode后并将它们重新排列以达到快速执行的目的。

常见的php加速器有：

1、APC (Alternative PHP Cache)
遵循PHP License的开源框架，PHP opcode缓存加速器，目前的版本不适用于PHP 5.4。项目地址，http://pecl.php.net/package/APC。

2、eAccelerator
源于Turck MMCache，早期的版本包含了一个PHP encoder和PHP loader，目前encoder已经不在支持。项目地址， http://eaccelerator.net/。

3、XCache
快速而且稳定的PHP opcode缓存，经过严格测试且被大量用于生产环境。项目地址，http://xcache.lighttpd.net/

4、Zend Optimizer和Zend Guard Loader
Zend Optimizer并非一个opcode加速器，它是由Zend Technologies为PHP5.2及以前的版本提供的一个免费、闭源的PHP扩展，其能够运行由Zend Guard生成的加密的PHP代码或模糊代码。 而Zend Guard Loader则是专为PHP5.3提供的类似于Zend Optimizer功能的扩展。项目地址，http://www.zend.com/en/products/guard/runtime-decoders

5、NuSphere PhpExpress
NuSphere的一款开源PHP加速器，它支持装载通过NuSphere PHP Encoder编码的PHP程序文件，并能够实现对常规PHP文件的执行加速。项目地址，http://www.nusphere.com/products/phpexpress.htm

php的配置文件在/etc/php.ini和/etc/php.d/*.ini。配置文件（php.ini）在PHP启动时被读取。对于服务器模块版本的PHP，仅在web服务器启动时读取一次。对于CGI和CLI 版本，每次调用都会读取。

php.ini核心配置选项：http://php.net/manual/zh/ini.core.php
php.ini配置选项列表：http://php.net/manual/zh/ini.list.php

## Mariadb

Mariadb是关系型数据库的一种开源实现，数据结构模型有层次模型、网状结构、关系模型。关系模型将数据组织成二维关系，由行和列组成。

**RDMBS设计范式**

设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。

(1) 第一范式（1NF）

所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。

说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。

(2) 第二范式(2NF)

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

(3) 第三范式（3NF）

第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。































